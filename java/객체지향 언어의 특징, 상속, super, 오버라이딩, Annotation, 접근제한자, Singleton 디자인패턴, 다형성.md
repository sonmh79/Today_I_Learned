# 220721 객체지향 언어의 특징, 상속, super, 오버라이딩, Annotation, 접근제한자, Singleton 디자인패턴, 다형성

# 객체지향 언어의 특징 4

**추상화** - 현실 객체를 추상화 하여 클래스화 한다.

**다형성** - 하나의 객체를 여러 가지 타입으로 참조할 수 있다.

**상속** - 부모 클래스의 자산을 물려받아 자식을 정의하여 코드 재사용이 가능하다.

**데이터 은닉과 보호** - 외부로부터 내부 데이터의 접근을 제한할 수 있다.

# 상속(Is a)

### What

부모의 클래스를 물려받아 그 기능을 수정 및 확장할 수 있는 개념이다.

### How

모든 객체는 기본적으로 `Object`를 상속 받는다. 그래서, Object가 가진 메서드들을 사용할 수 있다. (`equals`, `toString` .. )

부모 클래스서 자식 클래스로 **명시적 형변환**이 가능하다.

```java
Public boolean isEqual (Object obj) {
	return this.book.isbn.equals(((Book)obj).isbn); // Object -> Book 자식클래스로 형변환
}
```

상속은 **Is a** 관계라고도 표현한다. ex) `SpiderMan` **is a** `Person`

자바에서는 복잡한 관계를 방지하기 위해 **단일 상속만 지원**한다. → `interface`와 **포함(has a)** 관계로 보완한다.

**상속** - `SpiderMan` **is a** `Person` . 화살표(→)로 표현한다.

- `SpiderMan` → `Person`

**포함** - `SpiderMan` **has a** `Spider` . `Spider`의 기능을 사용할 수 있다. 실선(ㅡ)으로 표현한다.

- `Spider` - `SpiderMan`

### Use

부모의 코드를 수정하면 자식에게도 적용되기 때문에 **유지보수성이 높아진다**.

상속이냐 포함이냐 정답은 없다. 프로젝트의 관점에 따라 상속과 포함이 달라질 수 있다.

### Notice

부모 클래스에서 기본 생성자 없이 **새로운 생성자를 만들면** 자식 클래스에서 오류가 발생할 수 있다.

자식 클래스의 생성자에서 `super()` 가 생략되어 있기 때문에 부모 클래스의 생성자와 맞춰줘야 한다.

---

# super

### What

부모 클래스를 참조하는 변수이다.

### How

`super()` 를 통해 부모 클래스의 생성자를 호출할 수 있다.

`super.` 를 통해 조상 클래스 멤버에 접근할 수 있다.

어떤 변수를 찾을 때, 사용된 위치에서 점점 확장해가며 처음 만난 선언부에 연결된다.

- method 내부 → 해당 클래스 → 부모 및 조상 순으로 탐색한다.

### Use

부모 클래스에서 이미 정의된 멤버 변수를 그대로 사용하여 코드 중복을 막을 수 있겠다.

---

# 오버라이딩(=메서드 재정의)

### What

부모 클래스에서 물려받은 메서드를 자신의 방식으로 **재정의** 하는 것, **덮어쓰기**

### How

오버라이딩 시에는 **부모의 제한자 범위와 같거나 넓은 범위로만** 재정의할 수 있다.

예를 들어, 부모의 접근제한자가 `protected`라면 오버라이딩 접근제한자는 `public` or `protected`여야 한다.

오버라이딩은 덮어쓰기인 반면, 오버로딩은 이름이 같지만 서로 다른 여러 개의 메서드들이다.

### Use

부모 클래스를 상속 받는 자식 클래스에서 물려 받은 메서드를 조금 더 사용자화, 비즈니스 서비스에 맞추어 재정의 할 수 있을 것이다.

---

# Annotaion

### What

컴파일러에게 아래의 코드에 대해 알려주는 것으로 컴파일러는 이를 토대로 개발자에게 도움을 줄 수 있다.

컴파일러, JVM, 프레임워크 등이 볼 수 있다.

### How

소스코드에 메타 데이터를 삽입하는 형태이다. `@` 를 사용한다.

ex) `@Override` - 오버라이딩된 메서드라고 알려준다. 오타가 나면 알려준다.

### Use

프레임워크를 사용하여 개발할 때, 많은 코드를 작성하다 보면 놓치는 부분이 생길 수 있다.

어노테이션을 사용하여 컴파일러, 프레임워크의 도움을 받아 개발 생산성을 향상시킬 수 있을 것이다.

---

# 접근제한자

### What

접근제한자를 사용하여 외부로부터 **자원을 은닉하고 보호**할 수 있다.

### How

`public` - 누구나 사용 가능

`protected` - 같은 패키지 내에서만 사용 가능, **다른 패키지에서 상속 받으면 사용 가능**

`package(default)` - **동일한 패키지 내**에서만 사용 가능

`private` - **해당 클래스 내**에서만 사용 가능, **캡슐화,** `Getter`와 `Setter`로 컨트롤한다.

그 외,

`final` - 마지막 더 이상 **바뀔 수 없다**. 확장할 수 없음, **오버라이딩을 할 수 없다.**

→ 이미 완벽한 클래스들에 사용한다. ex) String, Math .. 등등

→ `class`, `method`, `variable`에 사용하여 고정시킨다.

### Use

외부로부터 함부로 자원에 접근하여 사용할 수 없도록 할 수 있다.

`private` 을 아마 가장 많이 쓸 것 같다.

---

# Singleton 디자인 패턴

### What

**객체를 하나만 만들어서** 불필요한 생성 및 삭제를 통한 메모리 사용 소요를 줄일 수 있다.

### How

생성자를 `private`으로 만들고 `getter`만 만들어 새로운 객체 생성을 막는다.

객체 생성 없이 접근을 해야하기 때문에 `static getter` 를 만든다.

```java
class SingletonClass {
	private SingletonClass(){}; // 생성자 - 외부에서 new를 사용한 객체 생성 제한
	private static SingletonClass sc = new SingletonClass(); // 클래스 내부에서 하나의 객체 생성

	public static SingletonClass getSingletonClass() {
		return sc; // 외부에서 하나의 객체만 공유
}
}
```

---

### Use

굳이 저장이나 수정이 필요한 멤버 변수가 없이 **메서드만 있는 stateless한 객체에 적합**하다.

이러한 클래스는 계속해서 생성할 필요가 없기 때문이다.

---

# 다형성(Polymorphism)

### What

하나의 객체가 **여러 타입(형)을 가질 수 있는 성질**을 의미한다.

상속 관계에 있을 때, 부모 클래스 to 자식 클래스로, 자식 to 부모 클래스로 변환이 가능하다.

### How

형변환을 통해 변환된 객체는 **해당 타입의 메서드만 사용할 수 있다**.

**묵시적 형변환** - child to super, **자손 to 조상**, 자동 형변환이 일어난다, 어차피 자식은 조상의 모든 기능을 가지고 있기 때문에 문제되지 않는다.

**명시적 형변환** - super to chlid, **더 하위 클래스로(자손으로)** 형변환 시 명시가 필요하다.

조상을 무작정 자손으로 바꿀 수 없다. 메모리의 객체는 자손의 데이터가 없을 수가 있다. 때문에 컴파일 에러가 발생할 수도 있다.

```java
// SpiderMan을 통해 만들어진 객체인가요?? 형변환이 가능할까요 ??
if (obj instanceof SpiderMan) {
	SpiderMan sp = (SpiderMan) obj;	// 그렇담 형변환 할게요 ~
}
```

### Use

1. 서로 다른 타입의 객체를 하나의 배열로 관리할 수 있다.
   1. `Object[]`로 어떤 타입의 객체라도 저장할 수 있다.
   2. 다만, **기본형은 담을 수 없다. ?? → No**, autoboxing을 통해 Integer로 **자동 래핑**되어 들어갈 수 있다.
2. `println` 메서드는 **Object클래스를 파라미터로** 받기 때문에 **어떤 타입도 하나의 메서드로 받을 수 있다**.

### Notice

자식 클래스에서 부모의 메서드를 오버라이딩하면, 해당 객체는 그것에 최적화 되어있기 때문에 형변환을 통해 다른 타입으로 바뀌어도 오버라이딩된 메서드를 호출한다.

즉, 객체는 **오버라이딩된 메서드에 최적화** 되어있다.

`println`은 `Object` 객체를 파라미터로 받고 있지만, 그것의 `toString` 메서드 호출 시, **최하위 클래스에서 재정의된 `toString` 메서드를 호출한다.**

결론, 메서드가 중복될 때 무조건 자식 클래스의 메서드를 호출한다.

### 다형성에 대한 고찰

상위 클래스로 올라갈수록 활용도가 증가한다.

그렇다면 무작정 파라미터를 `Object`로 받는 것이 좋을까 ??

→ No, 객체 타입을 확인하는 코드가 추가되어야 해서 복잡성이 증가할 수 있다.

상위 클래스에서는 **하위 클래스의 메서드를 사용하지 못할 수도 있다.**

따라서, 비즈니스 로직 상의 최상위 객체 사용하여 불필요한 타입 확인 코드를 작성하는 소요를 줄이자.
