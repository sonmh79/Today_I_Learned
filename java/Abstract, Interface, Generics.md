# 220725 Abstract, Interface, Generics

# Abstract 추상 클래스

### What

(자식 클래스의 관점에서) 조상 클래스의 메서드 구현은 관심이 없다. 어차피 자식 클래스에서 **반드시 재정의** 되어야 하기 때문이다. `abstract` 키워드를 붙여 구체적인 구현을 생략해준다.

### How

메서드의 선언부만 남기고 구현부는 세미콜론으로 대체한다.

객체를 생성할 수 없는 클래스가 되지만, 추상 클래스로 **형변환은 가능**하다.

### Use

자식 클래스에서 **구현을 강제**하여 혹시나 발생할 수 있는 오류를 방지한다.

# Interface

### What

사용자와 실제 구현 사이의 **접점**이다. 클라이언트와 서버 사이의 접점

어떤 접점을 기준으로 사용자는 사용 부분에, 설계자는 구현에 관심이 있다.

메서드만 명시하고 **구현은 하지 않는다.**

### How

모든 멤버변수는 `public static final` 이고, 생략이 가능하다.

모든 메서드는 `public abstract`, 생략이 가능하다.

일반 클래스와 달리 **다중 상속 가능** !! - 실제 메서드를 구현하지 않아 헷갈리지 않기 때문이다.

### Use

1. 구현의 강제로 표준화 가능하다 → 손쉬운 모듈 교체 지원
2. **서로 상속 관계가 없는 클래스들에게 인터페이스를 통한 관계 부여로 다형성 확장**

   → 기존에는 일일이 하나씩 `instanceof`로 타입을 확인하고 메서드를 실행시켰어야 했다.

   → 인터페이스는 다중 상속이 가능하기 때문

   → ex) `Phone`, `Camara` 같이 충전이 필요한 객체를 `Chargable` 인터페이스로 묶어 위의 타입을 확인하는 과정을 간소화할 수 있다.

3. 모듈 간 독립적 프로그래밍 가능 → 개발 기간 단축
   1. 프론트와 백엔드는 공통된 `Interface`만 보고 **병렬 작업** 후 최종적으로 합치기
   2. 계산 기능에 대해 `CalculatorStub`(사용부) ↔ `CalculatorImpl`(구현부)
   3. 나중에 `CaculatorStub`을 `CalculatorImpl`로 교체하면 된다.

# Interface - default

### What

기존 `Interface` 기반 동작하는 라이브러리의 `Interface`에 기능을 추가해야 할 때가 있다.

### How

`default` 키워드를 추가하면 (abstract X) 상속 받은 클래스에서 오버라이드 할 필요가 없다.

추상 클래스의 필요성이 약해짐.

### Use

?클래스 간 메서드의 유무의 차이가 발생하는데 또 일일이 확인 ? - ex) 무풍 에어컨에 dry기능 추가 시

# Generics

### What

메서드의 파라미터를 임의로 참조변수 타입 `T` 로 입력 받고, 이전에 구현된 내부 T에 모두 라벨링한다.

들어오는 타입으로 라벨링을 하여 해당하는 타입만 담을 수 있다. 뺄 때도 타입을 예측하기 쉽다.

### How

`Object` 로 담을 시 - 넣을 때는 뭐든지 담을 수 있다는 장점이 있지만, 뺄 때는 타입을 알 수 없다는 단점이 있다.

꺼낼 때 타입을 확인하는 과정을 거쳐야 한다.

**런타임 시 타입에 대한 체크** 후 에러 발생한다.

하지만, `Generics<T>`는 **컴파일 시점에 타입에 대한 체크** → 오류를 잡아준다. 안정성이 향상되고, 형변환 필요 없다.

type parameter를 제한할 수 있다.

`public class NumberBox<T extends Number>` → `Number` 이하의 타입으로 제한 (`Number`를 상속받은 타입들만 사용 가능) - `extends` 대신 `super` 사용 시 , 조상 타입 사용으로 제한

### Use

컴파일 시점에서 자료형을 예측할 수 있다는 장점이 있다. 기대하는 파라미터의 타입을 제한하고자 할 때 유용할 것이다.
