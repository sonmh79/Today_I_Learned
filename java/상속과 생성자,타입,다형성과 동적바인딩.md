# 220722 상속과 생성자, 타입, 다형성과 동적 바인딩

# 상속과 생성자

### What

상속 받은 자식 클래스 생성자는 **반드시 부모 클래스를 먼저 호출**하고 자신의 일을 수행해야 한다.

### How

생성자 내에 반드시 `super()`가 최상단에 위치해야 한다.

컴파일러는 생성자가 없으면, **기본 생성자를 생성**하고 **부모 클래스를 호출**한다.

```java
public class Shape {
	private x;
	private y;

	public Shape(int x, int y) { // 생성자 명시 -> 기본 생성자 안만들어준다.
		this.x;
		this.y;
}
}

// 컴파일 오류 발생
public class Circle extends Shape {
}

// 컴파일러가 기본 생성자를 생성한다. 그리고 그 안에는 super()를 통해 부모를 호출하지만, 부모 클래스에는 기본 생성자가 없다.
// 그래서 부모 생성자와 맞추어 주어야 한다. ->super(x,y) 선언이 필요하다.
```

### Use

상속 받은 클래스를 사용할 때는 부모 클래스가 생성자를 통해 무엇을 요구하는지 확인하고 맞춰줘야한다.

---

# 상속과 참조변수 타입

### What

참조변수의 타입을 명시하여 컴파일러에게 기대치를 알려줄 수 있다.

### How

부모클래스에서 자식클래스로 상속을 통해 기능은 더욱 확장되고 시야가 넓아진다.

그렇기에 자식클래스에서 부모클래스로의 변환은 (시야가 좁아지는 변환은) 어떤 메서드나 변수를 사용함에 있어 문제되지 않는다.

하지만 부모클래스에서 자식클래스로의 변환은 문제를 야기할 수 있다.

객체가 변환하려는 자식클래스의 데이터를 가지고 있다면, 메모리에 데이터가 있다면, 자식 클래스로 변환해도 메서드 사용에 문제되지 않지만, 그렇지 않을 시 문제가 발생한다.

따라서, 컴파일러는 자식 클래스에 부모 클래스를 대입하는 것을 허락하지 않는다. 형변환 명시를 직접 해주어야 한다.

정리하자면, 객체 참조 레벨은 자동으로 상위로 올라가며 탐색하지만, 내려갈 때는 명시적으로 형변환이 필요하다.

### Use

`instanceof`를 통해 타입을 확인하고 형변환을 하자!

```java
Rectangle r = new Rectangle(0,0,10,10); // Shape를 상속받은 자식 클래스
Shape s = r; // 자식에서 부모 클래스로 자동 형변환이 일어난다.

s instanceof Shape // true
s instanceof Rectangle // true
```

---

# 컴파일 오류와 런타임 오류

### What

컴파일 오류 - 문법적으로 오류가 있다.

런타임 오류 - 실행해보니 오류 발생한다.

---

# 다형성과 동적 바인딩

### What

오버라이딩은 덮어 쓰기가 아니다 ??? - 사실은 메서드가 두 개가 따로 있다.

### How

동적 바인딩을 통해 **자식 클래스의 메서드를 실행**시킨다.

동적 바인딩? - 런타임 시점에서(실제 메서드를 호출하는 시점에서) 참조하는 객체의 메서드를 실행한다.

→ 문법적 오류를 막을 수 있다. 부모의 메서드 말고도 자식에서 만든 메서드가 있으면 그것을 실행하겠다.

```java
public class Shape { // 부모
	private x;
	private y;

	public Shape(int x, int y) { // 생성자 명시 -> 기본 생성자 안만들어준다.
		this.x;
		this.y;
}
	public double getArea() {

}
}

public class Circle {
	...
	public class getArea() {  // 오버라이딩
		..
}
}
```

### Use

이미 만들어진 어떤 라이브러리를 사용 시, 어떤 객체가 파라미터로 들어올지 모르기 때문에 implements ? 혹은 다른 상속들을 사용해서 오버라이딩하면 기존에 있는 라이브러리를 편하게 사용할 수 있다.

예를 들어, Arrays의 sort 메서드를 사용하기 위해서는 Comparable<t>? 와 같은 다른 것들을 상속받으면 된다.
